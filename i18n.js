const translations = {
    ko: {
        nav: {
            home: "홈",
            about: "소개",
            projects: "프로젝트",
            contact: "연락처",
            colorpicker: "색상 선택기",
            ads: "광고",
            privacy: "개인정보처리방침"
        },
        hero: {
            tagline: "어둠의 한 줄기 빛이 되는 소프트웨어를 개발합니다",
            cta: "프로젝트 보기"
        },
        about: {
            title: "About Me",
            description: "개발자로서 사용자에게 도움이 되는 서비스를 만들고 있습니다.",
            skills: "기술 스택"
        },
        projects: {
            title: "Projects",
            viewGithub: "GitHub에서 보기 →"
        },
        contact: {
            title: "Contact",
            description: "함께 빛을 만들어갈 기회를 찾고 있습니다"
        }
    },
    en: {
        nav: {
            home: "Home",
            about: "About",
            projects: "Projects",
            contact: "Contact",
            colorpicker: "Color Picker",
            ads: "Ads",
            privacy: "Privacy Policy"
        },
        hero: {
            tagline: "Building software that brings light to darkness",
            cta: "View Projects"
        },
        about: {
            title: "About Me",
            description: "As a developer, I create services that help users.",
            skills: "Tech Stack"
        },
        projects: {
            title: "Projects",
            viewGithub: "View on GitHub →"
        },
        contact: {
            title: "Contact",
            description: "Looking for opportunities to create light together"
        }
    },
    ja: {
        nav: {
            home: "ホーム",
            about: "紹介",
            projects: "プロジェクト",
            contact: "連絡先",
            colorpicker: "カラーピッカー",
            ads: "広告",
            privacy: "プライバシーポリシー"
        },
        hero: {
            tagline: "闇に一筋の光をもたらすソフトウェアを開発します",
            cta: "プロジェクトを見る"
        },
        about: {
            title: "About Me",
            description: "開発者として、ユーザーに役立つサービスを作っています。",
            skills: "技術スタック"
        },
        projects: {
            title: "Projects",
            viewGithub: "GitHubで見る →"
        },
        contact: {
            title: "Contact",
            description: "一緒に光を作り出す機会を探しています"
        }
    }
};

const projectTranslations = {
  ko: {
    'gesture-color-picker': {
      title: 'Gesture Color Picker App',
      description: '제스처 기반 색상 선택 애플리케이션[준비중]',
    },
    'submarine-commander': {
      title: 'Submarine Commander Game',
      description: '잠수함 지휘 시뮬레이션 게임[준비중]',
    },
    'news-collector': {
      title: 'News Collector Android',
      description: '뉴스 수집 및 큐레이션 Android 앱',
    },
    sumiwake: {
      title: 'Sumiwake App Project',
      description: '스미와케 관리 애플리케이션',
    },
    'media-organizer': {
      title: 'Media Organizer',
      description: '미디어 파일 정리 및 관리 도구',
    },
    'elder-tel': {
      title: 'Elder Tel',
      description: '고령자를 위한 간편 전화 애플리케이션',
    },
    'secret-clip': {
      title: 'Secret Clip Diary',
      description: '개인 클립보드 일기 애플리케이션',
    },
    'child-screen': {
      title: 'Child Screen',
      description: '아동 스크린 타임 관리 도구',
    },
    'news-poster': {
      title: 'News Poster',
      description: '뉴스 포스팅 자동화 시스템',
    },
    'dice-story': {
      title: 'Dice Story',
      description: '주사위 기반 스토리텔링 게임',
    },
    'for-soccer': {
      title: 'For Soccer',
      description: '축구 팬을 위한 정보 플랫폼',
    },
  },
  en: {
    'gesture-color-picker': {
      title:
        'Gesture Color Picker App[The app is currently under development.]',
      description: 'Gesture-based color selection application',
    },
    'submarine-commander': {
      title:
        'Submarine Commander Game[The app is currently under development.]',
      description: 'Submarine command simulation game',
    },
    'news-collector': {
      title: 'News Collector Android',
      description: 'News collection and curation Android app',
    },
    sumiwake: {
      title: 'Sumiwake App Project',
      description: 'Sumiwake management application',
    },
    'media-organizer': {
      title: 'Media Organizer',
      description: 'Media file organization and management tool',
    },
    'elder-tel': {
      title: 'Elder Tel',
      description: 'Simple phone application for elderly users',
    },
    'secret-clip': {
      title: 'Secret Clip Diary',
      description: 'Personal clipboard diary application',
    },
    'child-screen': {
      title: 'Child Screen',
      description: 'Child screen time management tool',
    },
    'news-poster': {
      title: 'News Poster',
      description: 'News posting automation system',
    },
    'dice-story': {
      title: 'Dice Story',
      description: 'Dice-based storytelling game',
    },
    'for-soccer': {
      title: 'For Soccer',
      description: 'Information platform for soccer fans',
    },
  },
  ja: {
    'gesture-color-picker': {
      title: 'Gesture Color Picker App[現在、開発段階にあります。]',
      description: 'ジェスチャーベースのカラー選択アプリケーション',
    },
    'submarine-commander': {
      title: 'Submarine Commander Game[現在、開発段階にあります。]',
      description: '潜水艦指揮シミュレーションゲーム',
    },
    'news-collector': {
      title: 'News Collector Android',
      description: 'ニュース収集・キュレーションAndroidアプリ',
    },
    sumiwake: {
      title: 'Sumiwake App Project',
      description: 'スミワケ管理アプリケーション',
    },
    'media-organizer': {
      title: 'Media Organizer',
      description: 'メディアファイル整理・管理ツール',
    },
    'elder-tel': {
      title: 'Elder Tel',
      description: '高齢者向け簡単電話アプリケーション',
    },
    'secret-clip': {
      title: 'Secret Clip Diary',
      description: '個人クリップボード日記アプリケーション',
    },
    'child-screen': {
      title: 'Child Screen',
      description: '子供のスクリーンタイム管理ツール',
    },
    'news-poster': {
      title: 'News Poster',
      description: 'ニュース投稿自動化システム',
    },
    'dice-story': {
      title: 'Dice Story',
      description: 'サイコロベースのストーリーテリングゲーム',
    },
    'for-soccer': {
      title: 'For Soccer',
      description: 'サッカーファンのための情報プラットフォーム',
    },
  },
};

let currentLang = localStorage.getItem('language') || 'ko';

function setLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('language', lang);
    
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        const keys = key.split('.');
        let translation = translations[lang];
        
        for (const k of keys) {
            translation = translation[k];
        }
        
        if (translation) {
            element.textContent = translation;
        }
    });
    
    document.querySelectorAll('.project-card').forEach((card, index) => {
        const projectKeys = Object.keys(projectTranslations.ko);
        if (index < projectKeys.length) {
            const projectKey = projectKeys[index];
            const project = projectTranslations[lang][projectKey];
            if (project) {
                const titleElement = card.querySelector('h3');
                const descElement = card.querySelector('p');
                if (titleElement) titleElement.textContent = project.title;
                if (descElement) descElement.textContent = project.description;
            }
        }
    });
    
    document.querySelectorAll('.project-link').forEach(link => {
        link.textContent = translations[lang].projects.viewGithub;
    });
    
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-lang') === lang) {
            btn.classList.add('active');
        }
    });
    
    document.documentElement.lang = lang === 'ja' ? 'ja' : (lang === 'en' ? 'en' : 'ko');
}

document.addEventListener('DOMContentLoaded', () => {
    setLanguage(currentLang);
    
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const lang = btn.getAttribute('data-lang');
            setLanguage(lang);
        });
    });
    
    // Mobile menu toggle
    const menuToggle = document.querySelector('.menu-toggle');
    const navMenu = document.querySelector('nav ul');
    
    if (menuToggle) {
        // Add touch event support for Safari
        const toggleMenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            navMenu.classList.toggle('active');
            menuToggle.classList.toggle('active');
        };
        
        menuToggle.addEventListener('click', toggleMenu);
        menuToggle.addEventListener('touchstart', toggleMenu, { passive: false });
        
        // Close menu when clicking/touching outside
        const closeMenu = (e) => {
            if (!menuToggle.contains(e.target) && !navMenu.contains(e.target)) {
                navMenu.classList.remove('active');
                menuToggle.classList.remove('active');
            }
        };
        
        document.addEventListener('click', closeMenu);
        document.addEventListener('touchstart', closeMenu, { passive: true });
        
        // Close menu when clicking a link
        navMenu.querySelectorAll('a').forEach(link => {
            const handleLinkClick = () => {
                navMenu.classList.remove('active');
                menuToggle.classList.remove('active');
            };
            link.addEventListener('click', handleLinkClick);
            link.addEventListener('touchstart', handleLinkClick, { passive: true });
        });
    }
    
    // Header scroll effect
    const header = document.querySelector('header');
    let lastScroll = 0;
    
    window.addEventListener('scroll', () => {
        const currentScroll = window.scrollY;
        
        if (currentScroll > 100) {
            header.style.background = 'rgba(20, 20, 20, 0.95)';
            header.style.boxShadow = '0 4px 30px rgba(0, 0, 0, 0.3)';
        } else {
            header.style.background = 'rgba(30, 30, 30, 0.9)';
            header.style.boxShadow = '0 2px 20px rgba(0, 0, 0, 0.1)';
        }
        
        lastScroll = currentScroll;
    });
    
    // Dynamic shadow and candle flame effect
    const hero = document.querySelector('.hero');
    const candleContainer = document.querySelector('.candle-container');
    const shadowText = document.querySelector('.shadow-text');
    const tagline = document.querySelector('.tagline');
    const ctaButton = document.querySelector('.cta-button');
    const flameLetters = document.querySelectorAll('.flame-letter');
    const flameGlow = document.querySelector('.flame-glow');
    
    // Flame physics parameters
    let mouseX = 0, mouseY = 0;
    let animationId = null;
    const letterStates = Array.from(flameLetters).map(() => ({
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        scale: 1,
        intensity: 1,
        turbulence: Math.random() * Math.PI * 2
    }));
    
    // Natural flame animation
    function animateFlame() {
        const time = Date.now() * 0.0003; // 3x slower time scale
        
        flameLetters.forEach((letter, index) => {
            const state = letterStates[index];
            const rect = hero.getBoundingClientRect();
            const letterRect = letter.getBoundingClientRect();
            
            // Calculate distance from mouse
            const letterCenterX = letterRect.left - rect.left + letterRect.width / 2;
            const letterCenterY = letterRect.top - rect.top + letterRect.height / 2;
            const deltaX = mouseX - letterCenterX;
            const deltaY = mouseY - letterCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Wind effect based on mouse proximity and direction
            const windStrength = Math.max(0, 1 - distance / 400); // Larger influence radius
            const windAngle = Math.atan2(deltaY, deltaX);
            
            // Natural turbulence - much slower
            state.turbulence += 0.03; // 3x slower turbulence
            const turbulenceX = Math.sin(state.turbulence + index * 0.7) * 1.2;
            const turbulenceY = Math.cos(state.turbulence * 0.8 + index * 0.5) * 1.8;
            
            // Calculate flame deformation - gentler waves
            const baseWave = Math.sin(time * 1.2 + index * 0.3) * 0.8;
            const verticalWave = Math.cos(time * 0.8 + index * 0.2) * 1.2;
            
            // Apply wind effect - more gradual response
            const windForceX = Math.cos(windAngle) * windStrength * 8;
            const windForceY = Math.sin(windAngle) * windStrength * 6;
            
            // Smooth interpolation for more natural movement
            const smoothingFactor = 0.05; // Very smooth transitions
            state.offsetX += ((turbulenceX + baseWave - windForceX) - state.offsetX) * smoothingFactor;
            state.offsetY += ((turbulenceY + verticalWave - Math.abs(windForceY) * 0.5 - 3) - state.offsetY) * smoothingFactor;
            state.rotation += (((turbulenceX + windForceX) * 0.3) - state.rotation) * smoothingFactor;
            state.scale += ((1 + Math.sin(time * 1.5 + index * 0.4) * 0.03 - windStrength * 0.08) - state.scale) * smoothingFactor;
            state.intensity += ((1 - windStrength * 0.25) - state.intensity) * smoothingFactor;
            
            // Apply transformations
            letter.style.transform = `
                translate(${state.offsetX}px, ${state.offsetY}px)
                rotate(${state.rotation}deg)
                scale(${state.scale})
            `;
            
            // Adjust glow intensity - slower pulsing
            const glowSize = 18 + Math.sin(time * 0.8 + index * 0.2) * 3;
            const glowIntensity = state.intensity;
            letter.style.textShadow = `
                0 0 ${glowSize}px rgba(251, 191, 36, ${glowIntensity}),
                0 0 ${glowSize * 2}px rgba(251, 191, 36, ${glowIntensity * 0.5}),
                0 0 ${glowSize * 3}px rgba(251, 191, 36, ${glowIntensity * 0.3})
            `;
        });
        
        // Animate glow layer - much slower
        const glowScale = 1 + Math.sin(time * 0.6) * 0.06;
        const glowIntensity = 0.8 + Math.sin(time * 0.9) * 0.15;
        flameGlow.style.transform = `scale(${glowScale})`;
        flameGlow.style.opacity = glowIntensity;
        
        // Shadow animation
        const shadowOffsetX = letterStates.reduce((sum, state) => sum + state.offsetX, 0) / letterStates.length;
        const shadowOffsetY = letterStates.reduce((sum, state) => sum + state.offsetY, 0) / letterStates.length;
        shadowText.style.transform = `translate(${shadowOffsetX * 2}px, ${shadowOffsetY * 2 + 20}px)`;
        
        animationId = requestAnimationFrame(animateFlame);
    }
    
    // Start animation
    animateFlame();
    
    hero.addEventListener('mousemove', (e) => {
        const rect = hero.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
        
        // Dynamic shadow for other elements
        const candleRect = candleContainer.getBoundingClientRect();
        const candleCenterX = candleRect.left - rect.left + candleRect.width / 2;
        const candleCenterY = candleRect.top - rect.top + candleRect.height / 2;
        
        const deltaX = candleCenterX - mouseX;
        const deltaY = candleCenterY - mouseY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        const shadowDistance = Math.min(distance / 5, 50);
        const shadowX = (deltaX / distance) * shadowDistance;
        const shadowY = (deltaY / distance) * shadowDistance;
        const opacity = Math.max(0.1, Math.min(0.5, 1 - distance / 500));
        
        const taglineShadow = `${shadowX/2}px ${shadowY/2}px ${shadowDistance/2}px rgba(0,0,0,${opacity/2})`;
        const buttonShadow = `${shadowX/3}px ${shadowY/3}px ${shadowDistance/3}px rgba(0,0,0,${opacity/2})`;
        
        tagline.style.textShadow = taglineShadow;
        ctaButton.style.boxShadow = buttonShadow;
    });
    
    hero.addEventListener('mouseleave', () => {
        mouseX = 0;
        mouseY = 0;
        tagline.style.textShadow = 'none';
        ctaButton.style.boxShadow = 'none';
    });
    
    // Aceternity UI inspired card hover effect
    const projectCards = document.querySelectorAll('.project-card');
    
    projectCards.forEach(card => {
        card.addEventListener('mousemove', (e) => {
            const rect = card.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100;
            const y = ((e.clientY - rect.top) / rect.height) * 100;
            
            card.style.setProperty('--mouse-x', `${x}%`);
            card.style.setProperty('--mouse-y', `${y}%`);
        });
        
        card.addEventListener('mouseleave', () => {
            card.style.setProperty('--mouse-x', '50%');
            card.style.setProperty('--mouse-y', '50%');
        });
    });
    
    // Smooth scroll for navigation
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const target = document.querySelector(this.getAttribute('href'));
            if (target) {
                const offset = 100;
                const targetPosition = target.getBoundingClientRect().top + window.pageYOffset - offset;
                window.scrollTo({
                    top: targetPosition,
                    behavior: 'smooth'
                });
            }
        });
    });
});